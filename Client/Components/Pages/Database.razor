@page "/database"
@rendermode InteractiveServer
@inject ApiService Api
@implements IDisposable

<h3>Список записей из базы данных</h3>

<!-- Фильтр по дате -->
<div class="row g-2 mb-3">
    <div class="col-auto">
        <label class="form-label">От</label>
        <input type="datetime-local" class="form-control" @bind="fromLocal" />
    </div>
    <div class="col-auto">
        <label class="form-label">До</label>
        <input type="datetime-local" class="form-control" @bind="toLocal" />
    </div>
    <div class="col-auto d-flex align-items-end gap-2">
        <button type="button" class="btn btn-primary" @onclick="ApplyFilter" disabled="@isLoading">
            Применить фильтр
        </button>
        <button type="button" class="btn btn-outline-secondary" @onclick="ResetFilter" disabled="@isLoading">
            Сбросить
        </button>
        <button type="button" class="btn btn-outline-primary" @onclick="LoadRecords" disabled="@isLoading">
            @(isLoading ? "Загрузка..." : "Обновить данные")
        </button>
    </div>
</div>

<p>Текущее время: @(currentTime?.ToString("yyyy-MM-dd HH:mm:ss") ?? "—")</p>

@if (isLoading)
{
    <div class="alert alert-info d-flex align-items-center gap-2">
        <div class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></div>
        <span>Загрузка данных...</span>
    </div>
}
else if (!string.IsNullOrWhiteSpace(errorMessage))
{
    <div class="alert alert-danger">@errorMessage</div>
}
else if (records.Count == 0)
{
    <div class="alert alert-warning">Нет данных для отображения</div>
}
else
{
    <div class="alert alert-success">Данные загружены!</div>
    <table class="table table-striped table-hover">
        <thead>
            <tr>
                <th>Id</th>
                <th>Дата создания (UTC)</th>
                <th>Сообщение</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var record in records)
            {
                <tr>
                    <td>@record.Id</td>
                    <td>@record.DateCreated.ToString("yyyy-MM-dd HH:mm:ss")</td>
                    <td>@record.Message</td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private List<ApiService.Record> records = new();
    private bool isLoading;
    private string? errorMessage;
    private DateTime? currentTime;

    // Значения из <input type="datetime-local"> в локальном времени пользователя
    private DateTime? fromLocal;
    private DateTime? toLocal;

    // Минимальное время показа спиннера (мс)
    private const int MinSpinnerMs = 800;
    private Timer? _timer;

    protected override async Task OnInitializedAsync()
    {
        await LoadRecords();       // первичная загрузка
        await GetCurrentTime();    // запрос времени
        StartTimeUpdater();        // обновление времени раз в секунду
    }

    private async Task ApplyFilter() => await LoadRecords();

    private async Task ResetFilter()
    {
        fromLocal = null;
        toLocal = null;
        await LoadRecords();
    }

    private async Task LoadRecords()
    {
        if (isLoading) return;

        isLoading = true;
        errorMessage = null;
        records.Clear();
        await InvokeAsync(StateHasChanged); // показать спиннер сразу

        var sw = System.Diagnostics.Stopwatch.StartNew();

        try
        {
            // Конвертация локальных значений в UTC
            DateTime? fromUtc = fromLocal.HasValue
                ? DateTime.SpecifyKind(fromLocal.Value, DateTimeKind.Local).ToUniversalTime()
                : null;

            DateTime? toUtc = toLocal.HasValue
                ? DateTime.SpecifyKind(toLocal.Value, DateTimeKind.Local).ToUniversalTime()
                : null;

            // Если перепутаны границы — поменяем местами
            if (fromUtc.HasValue && toUtc.HasValue && fromUtc > toUtc)
                (fromUtc, toUtc) = (toUtc, fromUtc);

            // Вызов API через прокси
            var data = await Api.GetRecordsAsync(fromUtc, toUtc);
            records = data ?? new();
        }
        catch (Exception ex)
        {
            errorMessage = $"Ошибка загрузки данных: {ex.Message}";
            records = new();
        }
        finally
        {
            var remaining = MinSpinnerMs - (int)sw.ElapsedMilliseconds;
            if (remaining > 0) await Task.Delay(remaining);

            isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task GetCurrentTime()
    {
        try
        {
            currentTime = await Api.GetServerTimeAsync();
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            errorMessage = $"Ошибка получения времени: {ex.Message}";
        }
    }

    private void StartTimeUpdater()
    {
        _timer = new Timer(async _ => await GetCurrentTime(),
            null, TimeSpan.Zero, TimeSpan.FromSeconds(1));
    }

    public void Dispose() => _timer?.Dispose();
}
